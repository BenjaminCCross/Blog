<!DOCTYPE html>
<!-- https://benjaminccross.github.io/Blog/ -->
<html>
<title>Ben Cross</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Roboto'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
    html,
    body,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        font-family: "Roboto", sans-serif
    }

    table,
    th,
    li {
        border: 1px solid black;
    }
</style>

<body class="w3-light-grey">

    <!-- Page Container -->
    <div class="w3-content w3-margin-top" style="max-width:1400px;">

        <!-- The Grid -->
        <div class="w3-row-padding">

            <!-- Left Column -->
            <div class="w3-third">

                <div class="w3-white w3-text-grey w3-card-4">
                    <div class="w3-container">
                        <h1>Ben Cross - COMP 491-01</h1>
                    </div>
                    <div class="w3-container">
                        <p><i class="fa fa-briefcase fa-fw w3-margin-right w3-large w3-text-teal"></i>Computer Science
                            and
                            Mathematics Student</p>
                        <p><i class="fa fa-graduation-cap fa-fw w3-margin-right w3-large w3-text-teal"></i>Studies at
                            Dickinson
                            College</p>
                        <p><i class="fa fa-home fa-fw w3-margin-right w3-large w3-text-teal"></i>Boston, MA</p>
                        <p><i
                                class="fa fa-envelope fa-fw w3-margin-right w3-large w3-text-teal"></i>Benjamin.C.Cross@gmail.com
                        </p>
                        <p><i class="fa fa-phone fa-fw w3-margin-right w3-large w3-text-teal"></i>(978) 578-9548</p>
                        <hr>
                        <div class="w3-xxlarge w3-container w3-center w3-margin-top" style="color:teal;">
                            <a href="https://www.facebook.com/benjamin.cross.54/"><i
                                    class="fa fa-facebook-official w3-hover-opacity"></i></a>
                            <a href="https://www.instagram.com/benjaminccross/"><i
                                    class="fa fa-instagram w3-hover-opacity"></i></a>
                            <a href="https://www.linkedin.com/in/benjamincross96/"><i
                                    class="fa fa-linkedin w3-hover-opacity"></i></a>
                            <a href="https://github.com/benjaminccross/"><i
                                    class="fa fa-github w3-hover-opacity"></i></a>

                        </div>
                    </div>
                </div><br>

                <!-- End Left Column -->
            </div>

            <!-- Right Column -->
            <div class="w3-twothird">

                
                 <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Ethical Issues with Autonomous Cars</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>February 4th, 2020
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            In recent years autonomous vehicles (AVs) have consumed a massive portion of the public’s attention. So much of our life revolves around transportation. Many people (particularly in the us where people are much more spread out) drive to work or school or to do errands. In 2018, 36,560 people died in the US alone due to some kind of driving accident. The majority of these deaths are likely drugs and alcohol or distracted driving. It is clear that humans are not perfect drivers by any stretch of the imagination. So, if we are spending so much time driving and so many people are dying autonomous vehicles present a very attractive solution.
                        </p>
                        <p>
                            While there are a lot of merits to autonomous vehicles, particularly in the area of safety, concerns of ethics quickly pop up. Rules and regulations would need to be put into place to ensure the AVs would be able to operate effectively. However different regions have different regulations regarding cars, but also unique cultures around those rules. For example, while j-walking is technically illegal, it is so widely accepted as the norm that it would be hard to find some at fault for doing so even if it was the cause of an accident. This is not true in some cities though. Shenzen famously has started using facial recognition to automatically fine people caught j-walking near a camera. So, then the systems that drive these AVs need to be manipulatable from regional legislative parties. However, if you were to give the ability to tune how the car makes decisions to the owners you may be opening a pandoras box. Users may change a system that the legislation argues should sacrifice the driver when many people are at risk. Users have clear incentive to manipulate more than any other party.
                        </p>
                        <p>
                            It is important to also understand the position we are putting AVs in. Right now, AVs are in an infancy stage. There are very few circumstances in which you can let autopilot take over. Moreover, when we present these trolley problems as instances to say that it would be morally or ethically unsound to let AVs be released, we ignore the fact that trolley problems almost never happen. There is almost always a way we could have avoided being put in that position in the first place, and statistically speaking, an AV is a better driver that is more aware and able to prepare. We have a long way to go and the ethics do matter, but they shouldn’t be a yes or no on allowing AVs to exist but rather how do we incorporate these ideas into AVs.  
                        </p>
                    </div>
                    </br>
                </div>
                
                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Introduction To Ethics</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>January 28th, 2020
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            In reference to discussion we had in class about ethics, it is clear that there are no two
                            ways to approach the morals
                            and ethics of any situation. The different philosophical theories such as Kantianism and
                            utilitarianism end up acting as
                            more guidelines for a justification about thoughts on a subject, rather than alternative
                            solutions. What I mean by that
                            is that you can use many of these strategies as explanations for stances on both sides of a
                            moral question. Take the
                            worm example – was the release of the worm morally right under each framework? – one
                            argument would be that as a rule
                            infecting more computers with viruses is bad. So, a Kantian approach could say that
                            releasing the worm was bad as
                            releasing the worm broke clear moral rules. However, the whole idea of Kantianism is to act
                            with duty in mind. Kant
                            argued that people should act only from moral rules that can be considered universal moral
                            laws. If when you see a
                            problem harming many people, you should act to fix it were a universal law, then releasing
                            the worm would be totally
                            justified. This is just one example, but as you can see, the ethical theories can be applied
                            to support or deny any
                            argument.
                        </p>
                        <p>
                            The worm example is very extreme, however there are many questions about privacy lately and debates as to what should be protected under the law. Privacy is uniquely interesting as it quickly asks questions about what we agree to with and without clear and distinct reasoning. Facebook is a tool many of us use. However, to do so we give up our rights to many privacies. The benefit we see facebook giving us outweighs our concerns on privacy. Normally, there is an expectation that when using a service particularly that of commerce or medicine, that information is kept private. Facebook releasing that information however uses that as the major means for profit. Some see this as breaking a social contract. They have always had the ability to do this, however many people when signing up for the service don’t think of this and expected, or at least hoped otherwise. Going forwards then, it seems that while facebook and others get away with releasing information more liberally, people become more comfortable with this, effectively editing the social contract. 
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">COMP 491 Fall Reflections</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>December 20th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            Dickinson College's education mission is "to prepare young people, by means of a useful
                            education in the liberal arts
                            and sciences, for engaged lives of citizenship and leadership in the service of society."
                            Comp 491 attempts to make this
                            a reality by using open source software development as a teaching tool to cultivate a civic
                            disposition and civic
                            skills.
                        </p>
                        <p>
                            In many ways Comp 491 succeeds in doing this. Almost no aspect of the course should be done
                            alone. Coding exercises and
                            activities such as learning git or using build tools are all done in pairs or small groups
                            where communication is both
                            verbal and written in slack. This accomplishes two very important things: teaching students
                            how to properly communicate
                            with each other about complex issues, as well as how to document learnings so they can be
                            found and understood by
                            others. Some of the most difficult aspects of working on open source projects is interacting
                            with complicated
                            documentation or other developers all over the world. If students learn early how to
                            communicate these ideas effectively
                            in both writing and verbally, it can make the whole process much easier.
                        </p>
                        <p>
                            Group discussions continue this trend on how to communicate but more than anything it helps
                            broaden a student’s
                            perspective. We read many articles often talking about the impact of OSS, but also the kinds
                            of people who contribute
                            and the reasons they do. In talking about this we are forced to not only picture ourselves
                            giving back using OSS, but
                            also see what areas OSS succeeds or fails to effectively deliver quality products that serve
                            society in some way.
                        </p>
                        <p>
                            It is clear that OSS development is a very different process from that in industry. However,
                            having the opportunity to
                            spend time working using tools used in the real world, developing OSS allows us to get a
                            taste of working on large scale
                            products like that of many industry-based products. Furthermore, it empowers us to explore
                            our curiosity and connect
                            with real developers. These connections will hopefully last past COMP 491. So, the class has
                            given us many skills and
                            directed us on a path to give back using them. COMP 491 is a real success story for
                            Dickinson’s goal of developing
                            leaders in service of society.
                        </p>
                    </div>
                    </br>
                </div>


                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">FOSS Success Stories & CriticismsForum</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>December 12th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>Representation is always a problem in any field. Unfortunately, technology has been shown to
                            be one of the worst
                            industries for diversity. As a cis white male from an upper-middle-class background I fall
                            in the vast majority. This
                            has major ramifications on the kind of technology that is made and how effective it is. I am
                            more likely to be
                            interested in working on projects that would directly affect me and testing will only be
                            seen through the eyes of those
                            working on the projects till it is released. This was most notably seen in early computer
                            vision systems that often
                            could only recognize people of certain races because so many of the researchers looked so
                            similar.
                        </p>
                        <p>
                            OSS has been seen by many to be a solution to this. Unfortunately, it, too, has issues with
                            representation and does not
                            come solve many of the problems with representation effectively. The idea of meritocracy
                            suggests that the best
                            solutions bubble to the top and will be used and those who create them are justly rewarded
                            for that work. OSS, at a
                            glance, would seem to be a huge supporter of this. However, who gets to work on projects,
                            while no longer limited to who
                            is hired by a recruiter, is limited by the support a community gives to contributor and by
                            the freedom a contributor
                            has. Someone with a full-time job and kids is highly unlikely to work on an OSS project as
                            they simply don’t have time.
                            Furthermore, many women still feel like they can’t show accurate information about who they
                            are online and thus change
                            their profiles to be more gender neutral in appearance. So, while OSS makes strides to be
                            more representative, it still
                            falls short.
                        </p>
                        <p>
                            Many tech enthusiasts like understandably like to use technology as a solution to their
                            problems. Unfortunately, tech
                            can’t be the only answer to making tech more diverse. While systems like the IBM sentiment
                            analysis can be used to watch
                            for bias in some companies, basing who gets to take on opportunities exclusively by higher
                            scores leads to a clearly
                            segmented market. Clearer interviewing practices would help bridge this gap and allow
                            organizations to hire people with
                            new perspectives.
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">H/F/OSS Motivations</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>December 6th, 2019</h6>
                    <hr>
                    <div class="w3-container">
                        <p>Why do people and organizations make OSS? After an entire semester talking about this very
                            subject, it is clear that
                            gaining support is as much an art as it is a science. For individuals to support an OSS
                            project, they need the time to
                            invest in it, but also the capability to make changes. What actually drives users to join
                            though is what they get out of
                            supporting the software. They could be doing it out of sheer interest in the subject. There
                            is now open source software
                            in insulin pumps. So, developers with diabetes have a significantly higher interest in
                            working on these projects as it
                            may directly impact their lives. These people are more likely to go up the levels from user
                            to contributor.
                            Alternatively, developers may work on OSS projects in order to gain experience. Students
                            make up a large group in the
                            OSS community as they are still learning how to build software and showing commitment to OSS
                            is an incredible resume
                            builder
                        </p>
                        <p>
                            Individuals aren’t the only ones to work in OSS communities. Companies and businesses also
                            often utilize OSS. To make
                            this profitable they often employ one or more business models. These can include Support
                            Sellers in which the software
                            is open source but support and other services such as branding and tutorials require
                            subscriptions. Loss Leader is a
                            strategy in which the product is made freely available at a loss to the company in order to
                            gain users and cut out
                            competition from the market. Widget Frosting is the when the software is open source but the
                            hardware it runs on is sold
                            for profit. Lastly, Accessorizing is when companies sell goods or extensions relating to the
                            open source product. All of
                            these are traditional means of turning an OSS project into a more profitable venture for a
                            company.
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Software Processes</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>December 3rd, 2019</h6>
                    <hr>
                    <div class="w3-container">
                        <p>Agile as an idea is one of the best tools for strong CI/CD. As more of a set of values and
                            principals, it allows for a
                            work environment to dictate their own system to best fit the project but still helps guide
                            decision making. By opting to
                            agree with Agile Software Development, a team is more likely to have consistent, trackable
                            work that is closer in line
                            with what a customer wants.
                        </p>
                        <p>
                            Agile works best when paired with good practices. Scrum, for example, is a way of tracking
                            development and attributing
                            work in fairly. The idea behind scrum is that it sets aside time for “ceremonies” that tell
                            what work needs to get done
                            as well as retrospectives on previous work. Iterations, or sprints as they are called,
                            should be short enough that you
                            can have close connection with your users, but also have the time to make meaningful work
                            happen. This framework allows
                            developers to have a cyclic system that gives structure to the agile principles.
                        </p>
                        <p>
                            Fortunately, adhering to the Agile and working with scrum also gives you the freedom to work
                            in a test-driven
                            development cycle. Because you are always getting updates from your users as to how well
                            your software is working and
                            fitting their needs, you can convert their needs into tests so you know if your code is
                            reaching your deliverables. Then
                            build code to suite those tests. This is a much more efficient development strategy and one
                            that helps make sure your
                            code is meeting specifications as required and nothing is being left out
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Software Testing</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>November 26th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            Before we start talking about testing it is important to talk about why we test and what it
                            accomplishes. So much of our
                            lives are completely dependent on code someone wrote. Want to get from one city to another,
                            better hope the air traffic
                            control systems don’t have any flights landing into each other or in more recent unpleasant
                            memory don’t overcorrect
                            your plane’s flight angle into a nosedive (both have unfortunately happened). So, the code
                            in these systems needs to be
                            bullet proof (and probably redundant). That being said, even systems that don’t hold life
                            and death directly needs to be
                            properly tested. Often times code is used in places the author may have never intended so
                            making sure it works as
                            designed is crucial. Moreover, making sure your product is good enough for consumers will
                            likely mean you are going to
                            get more business.
                        </p>
                        <p>
                            So now that we know we have to test, let’s talk about some different forms of testing to
                            make sure your code works as
                            intended. First and foremost, there is Static Testing. Essentially this is the cursory
                            glance over a code base. This
                            helps developers spot issues like poor choices in algorithms or bad code style that would
                            make debugging a problem in
                            the future. This doesn’t actually test if your code works but rather if your code would be
                            maintainable in the future.
                            Next, there is Dynamic Testing. This is basically running your code and seeing if it works.
                            This can include unit tests,
                            integration tests, regression tests or any other kind of testing where the code itself is
                            run. Lastly there is white and
                            black box testing. This when your code is tested by a battery of test cases with either full
                            (white) or no (black)
                            access to the internal structure of the code. Good software should be tested rigorously with
                            as many strategies as
                            possible to ensure best performance.
                        </p>
                        <p>
                            The most important thing to understand about testing is that you will miss something. No
                            code is perfect. As bullet
                            proof as you think your code is there is always a vulnerability, because people wrote it and
                            people aren’t perfect. The
                            best you can do is think of as many test cases as you can build your code accordingly. This
                            is partially why OSS code is
                            considered far more reliable. More people are working on it brining more eyes and
                            importantly this means they are more
                            likely to think of new ways to test and break your code so that you can improve it.
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Software Patterns</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>November 19th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            Software design patterns are common structures in software that help developers communicate
                            about their code. Some of
                            the great advantages are that they help developers quickly and efficiently develop. When you
                            know what tool you need,
                            you don’t have to reinvent the wheel, just replicate it. Moreover, Software patterns are
                            designed around specific
                            problems. So, the trouble isn’t so much as building the code but rather in terms of choosing
                            the right pattern for the
                            problem.
                        </p>
                        <p>
                            Unfortunately, there are downsides to this as with any tool in CS. There are concerns about
                            over engineering and lack of
                            flexibility. When addressing a problem, you may be choosing a pattern that is extremely over
                            engineered to address it.
                            This usually leads to a lack of flexibility or overly complicated structuring. To mitigate
                            these concerns, it is
                            important to understand antipatterns. Antipatterns are common structures of code that lead
                            to inefficiencies. Avoiding
                            antipatterns requires planning and thoughtfulness as you need to think about possible future
                            issues that could affect
                            your code.
                        </p>
                        <p>
                            To better understand software patterns let’s look at a couple. Observer is common pattern
                            based on the publish-subscribe
                            architecture. The idea is that an observer watches an observable and is updated when the
                            observable publishes. This
                            pattern is designed to address issues of scalability. There are very few costs to adding
                            observers to a system so it
                            scales well, however it has downfalls in security as there is no handshake between observer
                            and observables. So when
                            addressing problems with communicating between systems, you need to think about the tradeoff
                            of scalability and
                            security.
                        </p>
                    </div>
                    </br>
                </div>

                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Software Flaws</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>November 8th, 2019</h6>
                    <hr>
                    <div class="w3-container">
                        <p>As the saying goes, “no battle plan survives contact with the enemy”. We find this to be
                            especially true when developing
                            software. A design plan is often made before any large project is built. This might outline
                            success criteria, or tools
                            to be used. Unfortunately, rarely does this design plan truly describe what the product
                            looks like when it is finally
                            delivered. This is due to several possible factors. Clients may change what they want or not
                            truly describe what they
                            want until after they have a basic mockup of the product. Additionally, technologies change
                            very rapidly, so the actual
                            tools to be used could be made obsolete during the design phase. Lastly, a design often
                            misses some real practical
                            limitations that could seem small in the document, but actually play a massive role in the
                            end product. This is not to
                            say that planning is not useful. A basic guiding document can help developers tune into the
                            business value they are
                            trying to hit. However, an extremely detailed and defined document can lock developers in
                            and can lead to poor final
                            products.
                        </p>
                        <p>
                            Incremental design helps developers properly develop given a very small guiding document.
                            The idea behind incremental
                            design is that you are reaching small deliverables to show to your users or clients in order
                            to get a better idea of
                            what they want and how to change things going forward. Additionally, this helps developers
                            spend time where they need to
                            rather than working on features that may not be needed. Addressing problems as they arise,
                            means that developers can hit
                            high priority targets first, and minor changes that don’t affect the end user last. This
                            also helps users from building
                            complex structures for planned future problems that may tie them down from reaching earlier
                            deliverables. In the end,
                            incremental development helps developers write useful code faster and create products
                            faster.
                        </p>
                    </div>
                    </br>
                </div>
                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">FOSS Licensing</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>November 1st, 2019</h6>
                    <hr>
                    <div class="w3-container">
                        <p>Licensing make the OSS world run. That document that goes along with the code, or product
                            that says how it should be
                            used or developed can dictate a lot about its versatility in several different ways. It will
                            likely explain whether the
                            code can be used in commercial use, if it can be modified and distributed, or if the code
                            can be held under other
                            licenses. This license is what makes open source software OPEN. When releasing your code, it
                            is important to understand
                            which license to use as there are some very crucial differences. The MIT license for example
                            is considered one of the
                            most free and open licenses there are. MIT doesn't require modifications be open sourced
                            whereas the GPL does require
                            any distributed changed versions of the code be open sourced. In general, this makes MIT far
                            less restrictive than the
                            GPL license.
                        </p>
                        <p>
                            There are often important changes made to licenses between versions as well. For example,
                            GPL had a large change between
                            versions 2 and 3 to prevent tivoization. Tivoization being defined as incorporating software
                            under the terms of a
                            copyleft software license (like GPL2) but using hardware restrictions to prevent users from
                            running modified versions of
                            the software on that hardware. The makers of GPL noticed this flaw in the license that
                            allowed Tivo to block users. They
                            updated the license to version 3 with the stipulation requiring the distributor to provide
                            you with whatever information
                            or data is necessary to install modified software on the device.
                        </p>
                    </div>
                    </br>
                </div>



                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Software Architectures</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>October 25th, 2019</h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            “It depends” -- quite possibly the worst answer to a question if not immediately followed by
                            an
                            explanation of the factors and what are needed. Software development is filled with this
                            answer and there
                            is no better example than in deciding on an architecture of a project. A project may work
                            extremely well
                            with one architecture but be near impossible to deliver using some other architecture. Then
                            understanding
                            the relative differences between architectures and how to implement them becomes vitally
                            important in
                            software development. If we see Software Architecture as the design of how different
                            components and
                            software interact with one another, there is a huge range of options. Deciding on which
                            architecture to
                            choose should be an ongoing discussion in a project but early on, making a decision for the
                            large-scale
                            architecture is important. While you can usually change the implementation down the line
                            with relative
                            ease, changing the entire architecture of a project can sometimes require a hard rewrite of
                            all the code.
                            It is for this reason that you must decide early on.
                        </p>
                        <p>
                            So, then how do you choose an architecture? First and foremost, it depends on the product
                            you are making.
                            Some projects will simply be easier to develop in one style versus another. For example,
                            take a network
                            stack. Most network stacks are a layered system where communication flows up and down the
                            stack of layers.
                            That isn’t to say it would be impossible to design one some other way, but it would be
                            easiest to design
                            it around a layering system. In addition to product however there are many “non-functional”
                            attributes.
                            These may include testing frameworks, security concerns, costs of maintenance, or
                            scalability. For
                            example, if security was a large concern, Event-based implicit invocation may not be the
                            best choice as
                            any information “broadcasted” may be picked up by any number of subscribers. There is no
                            “handshake” so
                            the publisher is relinquishing control of the computations, a possible security threat.
                            Every architecture
                            has it’s positives and negatives, and it is the job of the designer or PM to choose the
                            appropriate tool
                            for the job.
                        </p>
                    </div>
                    </br>
                </div>


                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Version Control 1, 2 and Activity</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>October 1st, 2019 -
                        (updated)
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>Version control is one of the most powerful tools in a software developer’s arsenal. It
                            allows you to
                            track the changes made to a file in a much more granular way, but when used properly it has
                            a world of
                            other features that can expand a project’s usage. Before jumping into those features, it is
                            important to
                            be on the same page regarding what makes up version control. For the purposes of this
                            article we will be
                            addressing version control as a system similar to Git. While there are other versions like
                            SVN, which we
                            will touch on at the end, Git’s copy-modify-merge structure and “one stop shopping” for
                            collaboration
                            makes it a good baseline to communicate effectively about version control.
                        </p>
                        <p>
                            At the end of the day, version control is simply a way of creating changes, collecting those
                            changes,
                            labeling them and publishing them. That last bit is where the magic really happens. Say you
                            have a file
                            “myAmazingCode.c” and you make, what you think to be, a revolutionary change to the code. So
                            you
                            understandably are tracking this file and your hordes of developers following this code are
                            delighted to
                            see you have pushed these changes to your github. They can fetch this code, allowing them to
                            see the
                            difference between your change and theirs. They can also attempt to merge your code with
                            their code.
                            Unfortunately, after testing your code they find it has completely ruined their code. The
                            wonderful aspect
                            of version control is that they can simply revert to a previous commit before they merged in
                            your changes.
                            So, no harm done. Moreover, they can be building on a separate branch and push their changes
                            to it, so as
                            to not harm your branch, and when their feature is complete merge their branch into master
                            on Github. This
                            incredible system of branching and merging means that while one developer is working on one
                            feature
                            another can be working on another feature independently but still be editing the same file.
                            Their changes
                            would then not impact each other until they attempt to merge, pulling each other’s code into
                            master or
                            their own branch to test integration.
                        </p>
                        <p>
                            A note on merging vs. rebasing. So far, I have exclusively talked about merging as the
                            operation to
                            connect one set of code with another. This however is a bit of a simplification. When
                            editing a file there
                            is a series of commit objects pointing down a tree. When merging, you are maintaining this
                            structure and
                            can see the history of the commits in the resulting merged code. Rebasing effectively does
                            the same thing,
                            however it does not maintain the history. When pulling the feature branch into the master,
                            instead of
                            seeing a list of commits from the feature branch, a developer can choose to “rewrite” (for
                            lack of a
                            better word) the history of the code being merged in as one large commit. Rebasing also has
                            the added
                            benefit of presenting the conflicts one commit at a time whereas a merge will present them
                            all at once.
                            So, when would you use one tool over another? Typically, a merge will do the trick. In most
                            cases, a
                            rebase is simply not necessary and maintaining the history of the code will help fix bugs
                            and track where
                            things may have gone wrong. A rebase, however, is not without its own merits. Rebasing
                            allows a developer
                            to simplify a large set of confusing commits into one easy to understand package. Both forms
                            have their
                            use cases and it is up to the developer to decide when one should be used over the other.
                        </p>
                        <p>
                            To close this post out a discussion on SVN vs Git is in order. Git, as described before, is
                            a
                            “copy-modify-merge” tool. That is, a file is copied not locked off from other users and
                            merged rather than
                            unlocked. This has the huge benefit of allowing multiple people to be working on the same
                            file in
                            different ways at the same time. In this way Git is a decentralized version control system.
                            It
                            dramatically increases developer’s “workspace”, meaning they can have any number of people
                            working on any
                            number of tasks in the same repository management without conflicting with one another. SVN
                            is in direct
                            opposition to Git in this way. It is a “lock-modify-unlock” tool. Because of this it would
                            be considered a
                            centralized version control system. When a developer wants to edit a file, they lock it off
                            from all other
                            developers. This restricts the workspace, as that file is now inaccessible. While SVN may be
                            wonderful in
                            a small team setting it makes no sense in a large open source software project.

                        </p>
                    </div>
                    </br>
                </div>



                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">H/FOSS Project Tools/Structures/Communication</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>September 17th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>A core problem that all open source projects need to face is how to get people to connect
                            with the
                            project. The project can’t exist without contributors, and there is no reason to build the
                            project without
                            users, so having ways to encourage those people to connect with the product is crucial for
                            its
                            development. There are a few ways of doing this. First and foremost, it comes from the
                            documentation. The
                            first impression anyone gets of a project is likely to be their homepage. Making sure that
                            it is clear
                            what the intent of the project is and how a someone can learn more is a great place to
                            start. This can
                            come in the form of a quick 3 sentence paragraph next to some images of the software. Having
                            this
                            immediately visible is extremely important. Beyond this, features lists, screenshots and
                            examples of use
                            cases help users know if this is the product for them and for developers to know that the
                            project already
                            has some feet under it. Of more importance to users than developers, is the getting started
                            page. Linked
                            to the homepage should be a page explaining how to start using the software, the best
                            projects often have
                            multiple versions, such as a fast setup, a video tutorial and a longer more in-depth
                            version.
                        </p>
                        <p>Now that you have your first set of users, you need make sure your developer community is
                            organized.
                            Contributors don’t want to work on projects with no support structure. Fortunately, most
                            repositories come
                            with built in ways of keeping development organized. First is the issue tracker. Github
                            supports issue
                            tracking, with convenient labeling so if some developers feel better in some areas over
                            others, they can
                            tailor their work to their experiences, or rank issues in terms of severity. Additionally,
                            issues can be
                            tracked so it can go through from identification to closer, keeping everyone interested
                            appraised of its
                            status, and any further details needed can be requested in a forum like structure. Most
                            importantly for
                            large scale projects is removal of duplicates and fortunately, in Github you can flag an
                            issue as
                            duplicate and redirect to the original. All issue tracker should have these features, but
                            some projects
                            may elect to use outside trackers such as Jira.
                        </p>
                        <p>Lastly, developers need effective ways of communicating. IRC, Email, Blogs, Forums, Slack,
                            Discord. All
                            of these are useful tools but must be applied to the proper instances. For example, I
                            wouldn’t try to hold
                            a slack conversation over email, because no one should have that many emails flying around.
                            Conversely, I
                            wouldn’t use slack as an emailing service because it would be very difficult to track the
                            chain of
                            conversation. Having the proper communication channels available to developers helps them
                            problem solve
                            and collaborate even if they are on opposite sides of the planet.
                        </p>
                        <p>A good open source project makes sure that anyone interacting with the project can
                            efficiently get access
                            to the information they need without confusion. In some ways, the projects homepage should
                            be the most
                            important, least used aspect of the project. You want users to quickly pick up the project
                            and start
                            using, and you want developers to be able to navigate to the code or documentation or
                            communication
                            quickly, so they aren’t wasting their time
                        </p>
                    </div>
                    </br>
                </div>


                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">H/FOSS Project Community</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>September 13th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>Software, like many tools needs some form updating, fixing, or sharpening. In the case of
                            software this
                            come in the form of maintenance of code and expansion of features. What may be a simple
                            piece of code at
                            first, given enough development and focus can turn into a feature rich, complex, user
                            friendly piece of
                            software. This is one reason why a single vendor may open their software up to be open
                            source. By open
                            sourcing a software, a vendor may be able to add more eyes to a project and get a more
                            community driven
                            direction to its future, making it a better product for users. This may be wonderful for the
                            company as
                            they can have the benefit of a larger workforce while still being able to have a say in the
                            direction it
                            will proceed in.</p>
                        <p>However, opening up a software is not something you can undo and has several drawbacks to a
                            vendor. If
                            the community version of a software is built up enough, few users may see a need to purchase
                            an expensive
                            licensed copy of the software. By making an OSS, the single vendor is accepting that there
                            needs to be a
                            freely accessible version for developmental purposes. This doesn’t mean they won’t make
                            money off of it,
                            but in many cases, if it is not made in an accessible way, many developers may take control
                            and push to
                            make an alternative cheaper solution. Loss of control is a huge hurdle when starting an open
                            source
                            project. When there is a disagreement, the community has an enormous amount of power, and
                            once a project
                            is open, the community can continue without the single vendor if need be. So, in many ways,
                            the single
                            vendor must try to keep the community happy and connected.</p>
                        <p>This brings on questions regarding forkability. In a nutshell forkability is the ability for
                            any
                            developer to take an existing open source project, copy the code and begin working on a
                            competing project.
                            The possibility of a fork is a very powerful force in open source development, maybe more so
                            than the
                            actual action of forking itself. This is what makes sure the community works to build
                            consensus on
                            direction and no benevolent dictator becomes a real dictator. Should the community feel the
                            current master
                            isn’t fairly supporting their vision, they can abandon the dictator and current master and
                            take the
                            project in a different direction.
                            This would be considered a hard fork, and from a single vendor perspective they should be
                            concerned. If
                            there is enough frustration, then by forking, the vendor would be losing most if not all
                            control over the
                            project. Forking however has it’s drawbacks. It not only hurts the vendor but also the
                            developers and
                            users, as a fork would be dividing the community, users and contributors in two. Meaning
                            there are less
                            people supporting the software in both branches. Additionally, any community engagement
                            tools or
                            infrastructure unique to the master would then need to be recreated for the new fork. So,
                            forking is a
                            costly power only to be wielded when there is strong support.
                        </p>
                    </div>
                    </br>
                </div>


                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">H/FOSS History & Philosophy</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>September 6th, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>
                            There are clearly many schools of thought on the structure of software development. It’s
                            clear that there
                            isn’t necessarily a single way of doing it and that these structures can mix somewhat but
                            that there are
                            distinct characteristics depending on the method used.
                        </p>
                        <p>
                            Two such structures that are seemingly at odds are the Cathedral and the Bazaar models. In
                            software
                            development these models. As addressed in our class discussion these two methods both have
                            pros and cons.
                            Many of the pros to the bazaar method are based around its size. With so many people taking
                            part, many
                            eyes mean a higher chance of someone spotting a bug, not to mention simply having more
                            people means more
                            working hours put into the project. However, these come at some costs that a smaller
                            cathedral model is
                            better at addressing. With a clear structured hierarchy in the cathedral model, large
                            structural changes
                            can happen much more smoothly as it is easier to make sure everyone is on the same page.
                            Additionally, it
                            is easy to accidentally duplicate work in a bazaar model whereas a cathedral model, tasks
                            can be doled out
                            and managed much more efficiently. Again, this is not to say one is better than the other,
                            simply that one
                            is easier to use in some circumstances than another. With a large community, the cathedral
                            model becomes
                            cumbersome, however, to start a bazaar model, there needs to be a lot of infrastructure to
                            properly direct
                            a varied community. Not to mention using the proper tools and documentation can mitigate the
                            downsides of
                            choosing one model over another.
                        </p>
                        <p>
                            None of the above structures matter to a project without first opening it up to the public.
                            This brings
                            out questions on the philosophy and even ethics of software. It would appear Richard
                            Stallman would argue
                            that the best software is open source and to be open you must obey the four freedoms.
                            Namely: 1) the
                            freedom to run the program as you wish, for any purpose; 2) the freedom to study how the
                            program works,
                            and change it so it does your computing as you wish; 3) the freedom to redistribute copies
                            so you can help
                            your neighbour; and lastly, 4) the freedom to distribute copies of your modified versions to
                            others. The
                            way a software is licensed will either allow or not allow for these freedoms. Calling a
                            software
                            “proprietary” is saying that the licensing somehow breaks these four crucial freedoms. By
                            making
                            proprietary software, you are making much easier to monetize, as the rights are then held
                            under company or
                            some other legal entity. This monetization aspect, while not exclusive to proprietary
                            software, then
                            allows for practices that are not user friendly.
                        </p>
                        <p>
                            This isn’t to say that proprietary software doesn’t have its place. Technology companies
                            need financial
                            support and having users pay to access their software is an understandable solution to this.
                            Furthermore,
                            this direct stream of money allows more of the funding to go directly into supporting the
                            software
                            development process and to pay developers for their services. That being said, I agree with
                            Stallman at
                            least to the point where I believe most software should at least have a feature rich FOSS
                            alternative.
                            Like how photoshop is impressive and extremely useful, you can do most things in GIMP, a
                            FOSS alternative.
                        </p>
                    </div>
                    </br>
                </div>



                <div class="w3-container w3-card w3-white w3-margin-bottom">
                    <h2 class="w3-text-grey">Hello World</h2>
                    <h6 class="w3-text-teal"><i class="fa fa-calendar fa-fw w3-margin-right"></i>September 3rd, 2019
                    </h6>
                    <hr>
                    <div class="w3-container">
                        <p>This Blog is being created in response to the Dickinson College senior seminar. Following
                            posts will be
                            reflective writings on the readings and discussions on topics of open source software
                            (FOSS), software
                            engineering and contemporary social and ethical issues in technology.</p>
                        <p>I plan on going into industry. I have a few offers from previous summer internships, though I
                            am still
                            shopping around find a job that will help me broaden my experience and skills. I feel due to
                            my past
                            experiences I have started to pigeon hole myself, and I want to ensure I keep learning new
                            technologies
                            and entering new fields.</p>
                    </div>
                    </br>
                </div>


                <!-- End Right Column -->
            </div>

            <!-- End Grid -->
        </div>

        <!-- End Page Container -->
    </div>

    <footer class="w3-container w3-center w3-margin-top">
    </footer>

</body>

</html>
